# Аутентификация (OAuth 2.0)

## Обзор

Доступ к OKS Group API осуществляется по протоколу OAuth 2.0. Система предназначена для межсерверного (M2M) взаимодействия и использует тип предоставления (`grant_type`) **`client_credentials`** для первичной аутентификации.

Процесс включает в себя обмен `Client ID` и `Client Secret` на временный `access_token`. Этот токен должен передаваться в заголовке `Authorization` при всех последующих запросах к защищенным ресурсам.

## Эндпоинт получения токена

- **Method:** `POST`
- **URL:** `/api/v1/service/token`

Этот эндпоинт обрабатывает все операции, связанные с выдачей и обновлением токенов, в зависимости от переданного `grant_type`.

---
### Grant Type: `client_credentials`

Этот тип предоставления используется для первичной аутентификации приложения.

#### Параметры запроса (`application/json`)
| Параметр        | Тип       | Обязательность | Описание                                       |
| --------------- | --------- | -------------- | ---------------------------------------------- |
| `grant_type`    | `string`  | Да             | Значение должно быть `"client_credentials"`.   |
| `client_id`     | `integer` | Да             | Идентификатор вашего клиентского приложения.     |
| `client_secret` | `string`  | Да             | Секретный ключ вашего клиентского приложения.  |

#### Пример запроса
```bash
curl -X POST "https://banking.oks-group.kz/api/v1/service/token" \
     -H "Content-Type: application/json" \
     -d '{
           "grant_type": "client_credentials",
           "client_id": 12345,
           "client_secret": "a1b2c3d4e5f6..."
         }'
```

#### Структура ответа
| Поле           | Тип      | Описание                                  |
| -------------- | -------- | ----------------------------------------- |
| `access_token` | `string` | JWT токен доступа.                        |
| `token_type`   | `string` | Тип токена. Всегда возвращает `"Bearer"`.   |
| `expires_in`   | `integer`| Время жизни токена в секундах.             |

---
### Grant Type: `refresh_token`

Этот тип предоставления используется для обмена действующего `access_token` на новый, что позволяет продлить сессию аутентификации без повторной передачи `client_secret`.

#### Параметры запроса (`application/json`)
| Параметр       | Тип      | Обязательность | Описание                                         |
| -------------- | -------- | -------------- | ------------------------------------------------ |
| `grant_type`   | `string` | Да             | Значение должно быть `"refresh_token"`.          |
| `access_token` | `string` | Да             | Действующий (не истекший) `access_token`.        |

#### Пример запроса
```bash
curl -X POST "https://banking.oks-group.kz/api/v1/service/token" \
     -H "Content-Type: application/json" \
     -d '{
           "grant_type": "refresh_token",
           "access_token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiI..."
         }'
```
Ответ имеет идентичную структуру ответа `client_credentials`.

---
## Использование Access Token

Для аутентификации запросов к ресурсам API (например, к каталогу) `access_token` должен быть передан в HTTP-заголовке `Authorization` со схемой `Bearer`.

**Формат заголовка:**
`Authorization: Bearer <access_token>`

---
## Обработка истечения срока действия токена

Токен доступа имеет ограниченный срок жизни, указанный в поле `expires_in` (в секундах). Ваше приложение должно корректно обрабатывать его истечение.

### Подход 1: Проактивное обновление по TTL
Этот подход требует отслеживания времени жизни токена (`TTL`) на стороне клиента для предотвращения ошибок `401`.

- **Алгоритм:**
    1.  При получении токена, клиент сохраняет его и вычисляет время истечения (`current_time + expires_in`).
    2.  Перед выполнением запроса к API, клиент проверяет, не истечет ли токен в ближайшее время (например, в течение следующих 60 секунд).
    3.  Если токен близок к истечению, клиент превентивно запрашивает новый токен, используя `grant_type: "refresh_token"`.
    4.  Запрос к API выполняется с уже обновленным токеном.

### Подход 2: Реактивное обновление по ошибке `401`
Упрощенный, но менее безопасный подход.
- **Алгоритм:**
    1.  Клиент использует токен до тех пор, пока API не вернёт ошибку `401 Unauthorized`.
    2.  В ответ на ошибку, клиент запрашивает новый токен (используя `grant_type: "client_credentials"`) и повторяет исходный запрос.

---
### Рекомендация

**Подход 1 (Проактивное обновление) является предпочтительным.**

Он соответствует лучшим практикам безопасности, так как **минимизирует количество передач `client_secret` по сети**. После первоначальной аутентификации, жизненный цикл токена управляется с помощью менее критичного `access_token`, что значительно уменьшает вектор атаки.

**Подход 2** является допустимой альтернативой для простых клиентов или сред, где реализация логики отслеживания TTL затруднена, при условии, что все соединения надёжно защищены с помощью TLS.